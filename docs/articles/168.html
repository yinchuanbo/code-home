<!DOCTYPE html>
<html lang="en">
  <head>
    <title>ES7、ES8、ES9、ES10、ES11、ES12都增加了哪些新特性？</title>
    <meta charset="utf-8">
    <meta name="description" content="This is a page">
    <meta name="keywords" content="page, sample">
    <meta name="author" content="None">
    <link rel="icon" href="../assets/images/code.svg" sizes="32x32" />
    <link rel="stylesheet" href="../assets/css/prism-okaidia.min.css">
    <link rel="stylesheet" href="../assets/css/articles.css">
</head>
<body>
  <!--<div class="article__wrapper_left">
    <div class="article__wrapper_left-mulu">目录</div>
    <ul class="articles__list"><li class="">
          <a href="/articles/167.html">
            跨域问题多种解决方案的精华总结
          </a>
        </li><li class="">
          <a href="/articles/166.html">
            纯前端如何实现录屏并保存视频到本地
          </a>
        </li><li class="">
          <a href="/articles/165.html">
            HTTP 缓存
          </a>
        </li><li class="">
          <a href="/articles/164.html">
            获取手指触摸位置
          </a>
        </li><li class="">
          <a href="/articles/163.html">
            JS的哪些新特性，你都用过么？
          </a>
        </li><li class="">
          <a href="/articles/162.html">
            前端接口防止重复请求实现方案
          </a>
        </li><li class="">
          <a href="/articles/161.html">
            一个聚合了所有中国独立开发者项目的资源
          </a>
        </li><li class="">
          <a href="/articles/160.html">
            滚动插件 BetterScroll, 增强用户交互体验
          </a>
        </li><li class="">
          <a href="/articles/159.html">
            快速了解CSS表单尺寸属性 field-sizing
          </a>
        </li><li class="">
          <a href="/articles/158.html">
            前端框架新势力大盘点
          </a>
        </li></ul>
  </div>-->
  <div class="article__wrapper_sidebar">
    <a href="/articles/"><svg t="1714001835347" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4298" width="48" height="48"><path d="M147.904 304.128l301.866667-179.541333a128 128 0 0 1 131.712 0.512l295.466666 178.88A128 128 0 0 1 938.666667 413.482667V810.666667a128 128 0 0 1-128 128H213.333333a128 128 0 0 1-128-128V414.144a128 128 0 0 1 62.570667-110.016z m43.626667 73.344A42.666667 42.666667 0 0 0 170.666667 414.144V810.666667a42.666667 42.666667 0 0 0 42.666666 42.666666h597.333334a42.666667 42.666667 0 0 0 42.666666-42.666666V413.482667a42.666667 42.666667 0 0 0-20.565333-36.501334l-295.466667-178.88a42.666667 42.666667 0 0 0-43.925333-0.170666l-301.866667 179.541333z" fill="currentColor" p-id="4299"></path><path d="M405.333333 469.333333h213.333334a42.666667 42.666667 0 1 1 0 85.333334H405.333333a42.666667 42.666667 0 1 1 0-85.333334z m0 85.333334a42.666667 42.666667 0 1 0 0-85.333334h213.333334a42.666667 42.666667 0 1 0 0 85.333334H405.333333z" fill="currentColor" p-id="4300"></path></svg></a>
    <a href="/tools/"><svg t="1714002003458" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6911" width="48" height="48"><path d="M817.87 556.31h-63.58v-66.24A42.27 42.27 0 0 0 712 447.8h-84.81a42.27 42.27 0 0 0-42.27 42.27v66.24H436.57v-66.24a42.27 42.27 0 0 0-42.27-42.27h-84.83a42.27 42.27 0 0 0-42.27 42.27v66.24h-61.83A22.39 22.39 0 0 0 183 578.7a22.39 22.39 0 0 0 22.39 22.39h61.81v65.55a42.27 42.27 0 0 0 42.27 42.27h84.83a42.27 42.27 0 0 0 42.27-42.27v-65.55h148.36v65.55a42.27 42.27 0 0 0 42.27 42.27H712a42.27 42.27 0 0 0 42.27-42.27v-65.55h63.58a22.39 22.39 0 0 0 22.39-22.39 22.39 22.39 0 0 0-22.37-22.39z m-438.64 95.26h-54.69V505.14h54.69z m317.72 0h-54.69V505.14H697z" p-id="6912" fill="currentColor"></path><path d="M823 202.58h-90.81v-63.09a71.88 71.88 0 0 0-71.88-71.88H363.19a71.88 71.88 0 0 0-71.88 71.88v63.08h-90.12A137.17 137.17 0 0 0 64 339.75v479a137.17 137.17 0 0 0 137.19 137.14H823a137.17 137.17 0 0 0 137.19-137.17v-479A137.17 137.17 0 0 0 823 202.58z m-474.36-54.1A23.52 23.52 0 0 1 372.17 125h279.16a23.52 23.52 0 0 1 23.52 23.52v54.1h-326.2z m554.23 673.31a76.76 76.76 0 0 1-76.76 76.76h-628a76.76 76.76 0 0 1-76.76-76.76V336.67a76.76 76.76 0 0 1 76.76-76.76h628a76.76 76.76 0 0 1 76.76 76.76z" p-id="6913" fill="currentColor"></path></svg></a>
  </div>
  <div class="article__wrapper">
    <div class="article__wrapper__main">
      <div class="article__wrapper_header">
        <h1>ES7、ES8、ES9、ES10、ES11、ES12都增加了哪些新特性？</h1>
        <span class="articles__home_time">2024/05/18 · YinHao</span>
      </div>
      <h1>ES7</h1>
<p>ES2016（ES7）中新增了如下特性 👇</p>
<ul>
<li><code>Array.prototype.includes</code></li>
<li><code>Exponentiation Operator</code></li>
</ul>
<h2>1. <code>Array.prototype.includes</code></h2>
<p><code>includes()</code>方法用来判断一个数组或字符串中是否包含一个指定的值</p>
<p><strong>返回值：</strong> 如果包含返回<code>true</code>，否则返回<code>false</code>。</p>
<p><strong>语法：</strong></p>
<ul>
<li><code>arr.includes(valueToFind)</code></li>
<li><code>arr.includes(valueToFind, fromIndex)</code></li>
</ul>
<pre><code class="language-js">let arr = [1, 2, 3, 4];
arr.includes(3); // true
arr.includes(5); // false
arr.includes(3, 1); // true
</code></pre>
<ul>
<li>fromIndex 大于等于数组长度，<strong>返回<code>false</code></strong><pre><code class="language-js">arr.includes(3, 3); // false
arr.includes(3, 20); // false
</code></pre>
</li>
<li>计算出的索引小于 0<br>
如果<code>fromIndex</code>为负值，使用<code>数组长度 + fromIndex</code>计算出的索引作为新的<code>fromIndex</code>，如果新的<code>fromIndex</code>为负值，则搜索整个数组。<pre><code class="language-js">arr.includes(3, -100); // true
arr.includes(3, -1); // false
</code></pre>
</li>
</ul>
<h2>2. <code>Exponentiation Operator</code>幂运算</h2>
<p>幂运算符<code>**</code>，相当于<code>Math.pow()</code></p>
<pre><code class="language-js">5 ** 2; // 25
Math.pow(5, 2); // 25
</code></pre>
<h1>ES8</h1>
<p>ES2017（ES8）新增了以下特性 👇</p>
<ul>
<li><code>Async functions</code></li>
<li><code>Object.entries</code></li>
<li><code>Object.values</code></li>
<li><code>Object.getOwnPropertyDescriptors</code></li>
<li><code>Trailing commas</code></li>
</ul>
<h2>1. <code>Async functions</code></h2>
<p><code>Async functions</code> 是 <code>async</code> 声明的函数，<code>async</code> 函数是 <code>AsyncFunction</code> 构造函数的实例，其中允许使用 <code>await</code> 关键字。</p>
<p><strong>返回值</strong>：一个<code>Promise</code></p>
<p><strong>语法：</strong></p>
<pre><code class="language-js">async function name([param[, param[, ...param]]]) {
 // statements
}
</code></pre>
<p><strong>举例：</strong></p>
<pre><code class="language-js">const promise = () =&gt; {
  console.log(&quot;1&quot;);
  return new Promise((resolve, reject) =&gt; {
    resolve(&quot;2&quot;);
  });
};
const asyncFun = async () =&gt; {
  console.log(&quot;3&quot;);
  const test = await promise();
  console.log(&quot;4&quot;, test);
};
asyncFun(); // 3 1 4 2
</code></pre>
<h2>2. <code>Object.entries</code></h2>
<p><strong>返回值</strong>：<code>Object.entries()</code>方法返回一个给定对象自身可枚举属性的键值对数组</p>
<p><strong>语法：</strong></p>
<pre><code class="language-js">Object.entries(obj);
</code></pre>
<p><strong>举例：</strong></p>
<pre><code class="language-js">let obj = { a: 1, b: 2 };
Object.entries(obj); // [['a', 1], ['b', 2]]
</code></pre>
<h2>3. <code>Object.values</code></h2>
<p><strong>返回值：</strong><code>Object.values()</code>方法返回一个给定对象自身可枚举属性值的数组</p>
<p><strong>语法：</strong><code>Object.values(obj);</code></p>
<p><strong>举例：</strong></p>
<pre><code class="language-js">let obj = { a: 1, b: 2 };
Object.values(obj); // [1, 2]
</code></pre>
<h2>4. <code>Object.getOwnPropertyDescriptors</code></h2>
<p><strong>返回值：</strong><code>Object.getOwnPropertyDescriptors()</code> 方法用来获取一个对象的所有自身属性的描述符</p>
<p><strong>语法：</strong><code>Object.getOwnPropertyDescriptors(obj);</code></p>
<p><strong>举例：</strong></p>
<pre><code class="language-js">let obj = { a: 1, b: 2 };
Object.getOwnPropertyDescriptors(obj); // [a: {configurable: true, enumerable: true, value: 1, writable: true}, b: {configurable: true, enumerable: true, value: 2, writable: true}]
</code></pre>
<h2>5. <code>Trailing commas</code> 尾后逗号</h2>
<p>如果你想要添加新的属性，并且在上一行已经使用了尾后逗号，你可以仅仅添加新的一行，而不需要修改上一行。</p>
<p>⚠️ JSON 不允许尾后逗号</p>
<p><strong>举例：</strong></p>
<ul>
<li>字面量中的尾后逗号
<ul>
<li>对象<pre><code class="language-js">let obj = {
  a: 1,
  b: 2,
};
</code></pre>
</li>
<li>数组<pre><code class="language-js">let arr = [1, 2];
</code></pre>
</li>
</ul>
</li>
<li>函数中的尾后逗号
<ul>
<li>参数定义<pre><code class="language-js">function(x, y) {}
function(x, y,) {}
(x, y) =&gt; {}
(x, y,) =&gt; {}
</code></pre>
</li>
<li>函数调用<pre><code class="language-js">fun(x, y);
fun(x, y);
</code></pre>
</li>
<li>不合法的尾后逗号
不含参数或者在剩余参数后面加逗号，都是不合法的尾后逗号<pre><code class="language-js">function(,) {}
(,) =&gt; {}
fn(,)
function(...arg,) {}
(...arg,) =&gt; {}
</code></pre>
</li>
</ul>
</li>
<li>解构中的尾后逗号<pre><code class="language-js">let [a, b] = [1, 2];
let { x, y } = { x: 1, y: 2 };
</code></pre>
</li>
<li>JSON 中的尾后逗号
JSON 中不允许出现尾后逗号<pre><code class="language-js">JSON.parse(&quot;[1, 2, 3,]&quot;); // ❌
JSON.parse('{&quot;a&quot;: 1,}'); // ❌
JSON.parse(&quot;[1, 2, 3]&quot;); // ✅
JSON.parse('{&quot;a&quot;: 1}'); // ✅
</code></pre>
</li>
</ul>
<h2>6. <code>String.prototype.padStart()</code></h2>
<p><code>padStart()</code> 用另一个字符串填充当前字符串。</p>
<p><strong>返回值：</strong> 在原字符串<strong>开头</strong>填充指定的填充字符串直到目标长度所形成的新字符串。</p>
<p><strong>语法：</strong></p>
<pre><code class="language-js">str.padStart(targetLength);
str.padStart(targetLength, padString);
</code></pre>
<ul>
<li>targetLength：当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。</li>
<li>padString（可选）：填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断。此参数的默认值为 &quot; &quot;。</li>
</ul>
<p><strong>举例：</strong></p>
<pre><code class="language-js">&quot;abc&quot;.padStart(10); // &quot;       abc&quot;
&quot;abc&quot;.padStart(10, &quot;foo&quot;); // &quot;foofoofabc&quot;
&quot;abc&quot;.padStart(6, &quot;123465&quot;); // &quot;123abc&quot;
&quot;abc&quot;.padStart(8, &quot;0&quot;); // &quot;00000abc&quot;
&quot;abc&quot;.padStart(1); // &quot;abc&quot;
</code></pre>
<h2>7. <code>String.prototype.padEnd()</code></h2>
<p><code>padEnd()</code> 方法会用一个字符串填充当前字符串（如果需要的话则重复填充）。</p>
<p><strong>返回值：</strong> 返回在原字符串<strong>末尾</strong>填充指定的填充字符串直到目标长度所形成的新字符串。</p>
<p><strong>语法：</strong></p>
<pre><code class="language-js">str.padEnd(targetLength);
str.padEnd(targetLength, padString);
</code></pre>
<ul>
<li>targetLength：当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。</li>
<li>padString（可选）：填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断。此参数的缺省值为 &quot; &quot;。</li>
</ul>
<p><strong>举例：</strong></p>
<pre><code class="language-js">&quot;abc&quot;.padEnd(10); // &quot;abc       &quot;
&quot;abc&quot;.padEnd(10, &quot;foo&quot;); // &quot;abcfoofoof&quot;
&quot;abc&quot;.padEnd(6, &quot;123456&quot;); // &quot;abc123&quot;
&quot;abc&quot;.padEnd(1); // &quot;abc&quot;
</code></pre>
<h1>ES9</h1>
<p>ES2018（ES9）新增了如下特性 👇</p>
<ul>
<li><code>Async iterators</code> 异步迭代器</li>
<li><code>Object rest properties</code> 剩余属性</li>
<li><code>Object spread properties</code> 扩展属性</li>
<li><code>Promise.prototype.finally</code></li>
</ul>
<h2>1. <code>Async iterators</code> 异步迭代器</h2>
<p><strong>返回值：</strong> <code>Async iterator</code> 对象的 next() 方法返回一个 <code>Promise</code>，这个 <code>Promise</code> 的返回值可以被解析成 <code>{value, done}</code> 的格式，</p>
<p><strong>语法：</strong><code>iterator.next().then(({value, done}) =&gt; {});</code></p>
<p><strong>举例：</strong></p>
<pre><code class="language-js">const asyncIterator = () =&gt; {
  const array = [1, 2];
  return {
    next: function () {
      if (array.length) {
        return Promise.resolve({
          value: array.shift(),
          done: false,
        });
      }
      return Promise.resolve({
        done: true,
      });
    },
  };
};
let iterator = asyncIterator();
const test = async () =&gt; {
  await iterator.next().then(console.log); // {value: 1, done: false}
  await iterator.next().then(console.log); // {value: 2, done: false}
  await iterator.next().then(console.log); // {done: true}
};
test();
</code></pre>
<h3>可以使用 <code>for-await-of</code> 在循环中异步调用函数</h3>
<pre><code class="language-js">const promises = [
  new Promise((resolve) =&gt; resolve(1)),
  new Promise((resolve) =&gt; resolve(2)),
  new Promise((resolve) =&gt; resolve(3)),
];
const test = async () =&gt; {
  for await (const p of promises) {
    console.log(&quot;p&quot;, p);
  }
};
test();
</code></pre>
<h2>2. <code>Object rest properties</code></h2>
<p><strong>举例：</strong></p>
<pre><code class="language-js">let test = {
  a: 1,
  b: 2,
  c: 3,
  d: 4,
};
let { a, b, ...rest } = test;
console.log(a); // 1
console.log(b); // 2
console.log(rest); // {c: 3, d: 4}
</code></pre>
<p><strong>⚠️ 注意：</strong></p>
<ul>
<li><code>null</code> 不能使用扩展运算符</li>
</ul>
<pre><code class="language-js">let { a, b, ...rest } = null; // ❌
</code></pre>
<h2>3. <code>Object spread properties</code></h2>
<p><strong>举例：</strong></p>
<pre><code class="language-js">let test = {
  a: 1,
  b: 2,
};
let result = { c: 3, ...test };
console.log(result); // {c: 3, a: 1, b: 2}
</code></pre>
<pre><code class="language-js">let test = null;
let result = { c: 3, ...test }; // {c: 3}
</code></pre>
<h2>4. <code>Promise.prototype.finally</code></h2>
<p>在<code>Promise</code>结束的时候，不管是结果是<code>resolved</code>还是<code>rejected</code>，都会调用<code>finally</code>中的方法</p>
<p><code>finally</code>中的回调函数不接受任何参数</p>
<p><strong>返回值：</strong> 一个 Promise</p>
<p><strong>语法：</strong></p>
<pre><code class="language-js">const promise = new Promise((resolve, reject) =&gt; {
  resolve(&quot;resolved&quot;);
  reject(&quot;rejectd&quot;);
});
promise
  .then((res) =&gt; {
    console.log(res);
  })
  .finally(() =&gt; {
    console.log(&quot;finally&quot;);
  });
</code></pre>
<p><strong>举例：</strong></p>
<pre><code class="language-js">const promise = new Promise((resolve, reject) =&gt; {
  resolve(1);
  reject(2);
});
const test = () =&gt; {
  console.log(3);
  promise
    .then((res) =&gt; {
      console.log(4, res);
    })
    .catch((err) =&gt; {
      console.log(5, err);
    })
    .finally(() =&gt; {
      console.log(6);
    });
};
test(); // 3 4 1 6
</code></pre>
<h1>ES10</h1>
<p>ES2019（ES10）新增了如下新特性 👇：</p>
<ul>
<li><code>Array.prototype.{flat, flatMap}</code>扁平化嵌套数组</li>
<li><code>Object.fromEntries</code></li>
<li><code>String.prototype.{trimStart, trimEnd}</code></li>
<li><code>Symbol.prototype.description</code></li>
<li><code>Optional catch binding</code></li>
<li>Array.prototype.sort() is now required to be stable</li>
</ul>
<h2>1. <code>Array.prototype.{flat, flatMap}</code> 扁平化嵌套数组</h2>
<h3>Array.prototype.flat</h3>
<p><code>flat()</code>方法会按照一个可指定的深度遍历递归<strong>数组</strong>，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。</p>
<p><strong>返回值：</strong> 一个新数组，不会改变旧数组。</p>
<p><strong>语法：</strong> <code>arr.flat([depth]);</code></p>
<ul>
<li><code>depth</code> 是数组遍历的深度，默认是 1。</li>
</ul>
<p><strong>举例：</strong></p>
<pre><code class="language-js">const arr = [1, 2, [[[[3, 4]]]]];
arr.flat(); // [1, 2, [[[3, 4]]]]
arr.flat(3); // [1, 2, [3, 4]]
arr.flat(-1); // [1, 2, [[[[3, 4]]]]]
arr.flat(Infinity); // [1, 2, 3, 4]
</code></pre>
<p><strong>⚠️ 注意：</strong></p>
<ul>
<li><code>flat()</code>会移除数组中的空项</li>
</ul>
<pre><code class="language-js">let arr = [1, 2, , , 3];
arr.flat(); // [1, 2, 3]
</code></pre>
<h4>手撕 flat</h4>
<pre><code class="language-js">function customFlat(arr, depth = 1) {
  if (!Array.isArray(arr) || depth &lt;= 0) {
    return arr;
  }
  return arr.reduce((pre, cur) =&gt; {
    if (Array.isArray(arr)) {
      return pre.concat(customFlat(cur, depth - 1));
    }
    return pre.concat(cur);
  }, []);
}
</code></pre>
<h4>替换</h4>
<ul>
<li><code>reduce</code>与<code>concat</code></li>
</ul>
<pre><code class="language-js">let arr = [1, 2, [3, 4]];
arr.reduce((arr, val) =&gt; arr.concat(val), []);
</code></pre>
<ul>
<li><code>...</code> 扩展运算符与<code>concat</code></li>
</ul>
<pre><code class="language-js">let arr = [1, 2, [3, 4]];
[].concat(...arr);
</code></pre>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat">更多替换方式请查看 MDN</a></p>
<h3>Array.prototype.flatMap</h3>
<p><code>flatMap()</code>方法首先使用映射函数映射数组（<strong>深度值为 1</strong>）的每个元素，然后将结果压缩成一个新数组。</p>
<p><strong>返回值：</strong> 一个新数组，并且每个元素都是回调函数的结果。</p>
<p><strong>语法：</strong></p>
<pre><code class="language-js">arr.flatMap(function callback(currentVal[, index[, array]]) {
}[, thisArg])
</code></pre>
<ul>
<li>callback: 可以生成一个新数组所调用的函数
<ul>
<li>currentVal: 当前数组在处理的元素</li>
<li>index: 可选，正在处理的元素索引</li>
<li>array: 可选，被调用的数组</li>
</ul>
</li>
<li>thisArg: 执行 callback 函数时使用的 this 值</li>
</ul>
<p><strong>举例：</strong></p>
<pre><code class="language-js">let arr = [&quot;My name&quot;, &quot;is&quot;, &quot;&quot;, &quot;Lisa&quot;];
let newArr1 = arr.flatMap((cur) =&gt; cur.split(&quot; &quot;)); // [&quot;My&quot;, &quot;name&quot;, &quot;is&quot;, &quot;&quot;, &quot;Lisa&quot;]
let newArr2 = arr.map((cur) =&gt; cur.split(&quot; &quot;)); // [[&quot;My&quot;, &quot;name&quot;], [&quot;is&quot;], [&quot;&quot;], [&quot;Lisa&quot;]]
</code></pre>
<h2>2. <code>Object.fromEntries</code></h2>
<p><code>fromEntries()</code> 方法会把键值对列表转换成一个对象</p>
<p><strong>返回值：</strong> 一个新的对象</p>
<p><strong>语法：</strong></p>
<pre><code class="language-js">Object.fromEntries(iterable);
</code></pre>
<ul>
<li>iterable: Array、Map 等可迭代对象</li>
</ul>
<p><strong>举例：</strong></p>
<pre><code class="language-js">let map = new Map([
  [&quot;a&quot;, 1],
  [&quot;b&quot;, 2],
]);
let mapToObj = Object.fromEntries(map);
console.log(mapToObj); // {a: 1, b: 2}
let arr = [
  [&quot;a&quot;, 1],
  [&quot;b&quot;, 2],
];
let arrToObj = Object.fromEntries(arr);
console.log(arrToObj); // {a: 1, b: 2}
let obj = { a: 1, b: 2 };
let newObj = Object.fromEntries(
  Object.entries(obj).map(([key, val]) =&gt; [key, val * 2])
);
console.log(newObj); // {a: 2, b: 4}
</code></pre>
<h2>3. <code>String.prototype.{trimStart, trimEnd}</code></h2>
<h3><code>String.prototype.trimStart</code></h3>
<p><code>trimStart()</code> 方法用来删除字符串的开头的空白字符。</p>
<p><code>trimLeft()</code> 是它的别名。</p>
<p><strong>返回值：</strong> 一个新的字符串，这个字符串左边的空格已经被去除掉了。</p>
<p><strong>语法：</strong></p>
<pre><code class="language-js">str.trimStart();
str.trimLeft();
</code></pre>
<p><strong>举例：</strong></p>
<pre><code class="language-js">let str = &quot;    a b cd  &quot;;
str.trimStart(); // 'a b cd  '
str.trimLeft(); // 'a b cd  '
</code></pre>
<h3><code>String.prototype.trimEnd</code></h3>
<p><code>trimEnd()</code> 方法用来删除字符串末尾的空白字符。</p>
<p><code>trimRight()</code> 是它的别名</p>
<p><strong>返回值：</strong> 一个新的字符串，这个字符串右边的空格已经被去除了</p>
<p><strong>语法：</strong></p>
<pre><code class="language-js">str.trimEnd();
str.trimRight();
</code></pre>
<p><strong>举例：</strong></p>
<pre><code class="language-js">let str = &quot;    a b cd  &quot;;
str.trimEnd(); // '    a b cd'
str.trimRight(); // '    a b cd'
</code></pre>
<h2>4. <code>Symbol.prototype.description</code></h2>
<p><code>description</code> 是一个只读属性</p>
<p><strong>返回值：</strong> 它返回 Symbol 对象的可选描述的字符串</p>
<p><strong>语法：</strong></p>
<pre><code class="language-js">Symbol(&quot;myDescription&quot;).description;
Symbol.iterator.description;
Symbol.for(&quot;foo&quot;).description;
</code></pre>
<p><strong>举例：</strong></p>
<pre><code class="language-js">Symbol(&quot;foo&quot;).description; // 'foo'
Symbol().description; // undefined
Symbol.for(&quot;foo&quot;).description; // 'foo'
</code></pre>
<h2>5. <code>Optional catch binding</code></h2>
<p>可选的捕获绑定，允许省略 catch 绑定和它后面的圆括号</p>
<p>以前的用法：</p>
<pre><code class="language-js">try {
} catch (err) {
  console.log(&quot;err&quot;, err);
}
</code></pre>
<p>ES10 的用法：</p>
<pre><code class="language-js">try {
} catch {}
</code></pre>
<h2>6. <code>JSON.stringify()</code> 的增强力</h2>
<p><code>JSON.stringify()</code> 在 ES10 修复了对于一些超出范围的 Unicode 展示错误的问题，所以遇到 0xD800-0xDFF 之内的字符会因为无法编码成 UTF-8 进而导致显示错误。在 ES10 它会用转义字符的方式来处理这部分字符而非编码的方式，这样就会正常显示了。</p>
<pre><code class="language-js">JSON.stringify(&quot;😊&quot;); // '&quot;😊&quot;'
</code></pre>
<h2>7. 修订 <code>Function.prototype.toString()</code></h2>
<p>以前的 toString 方法来自 <code>Object.prototype.toString()</code>，现在 的 <code>Function.prototype.toString()</code> 方法返回一个表示当前函数源代码的字符串。以前只会返回这个函数，不会包含空格、注释等。</p>
<pre><code class="language-js">function foo() {
  // es10新特性
  console.log(&quot;imooc&quot;);
}
console.log(foo.toString());
// function foo() {
//     // es10新特性
//     console.log('imooc')
// }
</code></pre>
<h1>ES11</h1>
<p>ES2020(ES11)新增了如下新特性 👇：</p>
<ul>
<li>空值合并运算符（Nullish coalescing Operator）</li>
<li>可选链 Optional chaining</li>
<li>globalThis</li>
<li>BigInt</li>
<li><code>String.prototype.matchAll()</code></li>
<li><code>Promise.allSettled()</code></li>
<li>Dynamic import（按需 import）</li>
</ul>
<h2>1. 空值合并运算符（Nullish coalescing Operator）</h2>
<h3>空值合并操作符（<code>??</code>）</h3>
<p><strong>空值合并操作符</strong>（<code>??</code>）是一个逻辑操作符，当左边的操作数为 <code>null</code> 或 <code>undefined</code> 的时候，返回其右侧操作符，否则返回左侧操作符。</p>
<pre><code class="language-js">undefined ?? &quot;foo&quot;; // 'foo'
null ?? &quot;foo&quot;; // 'foo'
&quot;foo&quot; ?? &quot;bar&quot;; // 'foo'
</code></pre>
<h3>逻辑或操作符（<code>||</code>）</h3>
<p><strong>逻辑或操作符</strong>（<code>||</code>），会在左侧操作数为假值时返回右侧操作数，也就是说如果使用 <code>||</code> 来为某些变量设置默认值，可能会出现意料之外的情况。比如 0、''、NaN、false：</p>
<pre><code class="language-js">0 || 1; // 1
0 ?? 1; // 0
&quot;&quot; || &quot;bar&quot;; // 'bar'
&quot;&quot; ?? &quot;bar&quot;; // ''
NaN || 1; // 1
NaN ?? 1; // NaN
false || &quot;bar&quot;; // 'bar'
false ?? &quot;bar&quot;; // false
</code></pre>
<h3>注意</h3>
<p>不可以将 <code>??</code> 与 AND（<code>&amp;&amp;</code>）OR（<code>||</code>）一起使用，会报错。</p>
<pre><code class="language-js">null || undefined ?? &quot;foo&quot;; // 抛出 SyntaxError
true || undefined ?? &quot;foo&quot;; // 抛出 SyntaxError
</code></pre>
<h2>2. 可选链 Optional chaining</h2>
<p><strong>介绍：</strong> <strong>可选链操作符</strong>（<code>?.</code>）允许读取位于连接对象链深处的属性的值，而不必明确验证链中的每个引用都是否有效。<code>?.</code> 操作符的功能类似于<code>.</code>链式操作符，不同之处在于，在引用为 <code>null</code> 或 <code>undefined</code> 时不会报错，该链路表达式返回值为 <code>undefined</code>。</p>
<p><strong>以前的写法：</strong></p>
<pre><code class="language-js">const street = user &amp;&amp; user.address &amp;&amp; user.address.street;
const num =
  user &amp;&amp; user.address &amp;&amp; user.address.getNum &amp;&amp; user.address.getNum();
console.log(street, num);
</code></pre>
<p><strong>ES11 的写法：</strong></p>
<pre><code class="language-js">const street2 = user?.address?.street;
const num2 = user?.address?.getNum?.();
console.log(street2, num2);
</code></pre>
<p><strong>⚠️ 注意：</strong></p>
<p>可选链不能用于赋值：</p>
<pre><code class="language-js">let object = {};
object?.property = 1; // Uncaught SyntaxError: Invalid left-hand side in assignment
</code></pre>
<h2>3. globalThis</h2>
<p>以前，在 Web 中，可以通过 <code>window</code>、<code>self</code> 取到全局对象，在 node.js 中，必须使用 <code>global</code>。</p>
<p>在松散模式下，可以在函数中返回 <code>this</code> 来获取全局对象，但是在严格模式和模块环境下，<code>this</code> 会返回 <code>undefined</code>。</p>
<p>以前要获取全局对象，可以定义一个函数：</p>
<pre><code class="language-js">const getGlobal = () =&gt; {
  if (typeof self !== &quot;undefined&quot;) {
    return self;
  }
  if (typeof window !== &quot;undefined&quot;) {
    return window;
  }
  if (typeof global !== &quot;undefined&quot;) {
    return global;
  }
  throw new Error(&quot;无法找到全局对象&quot;);
};
const globals = getGlobal();
console.log(globals);
</code></pre>
<p>现在 <code>globalThis</code> 提供了一个标准的方式来获取不同环境下的全局对象自身值。</p>
<h2>4. BigInt</h2>
<p>BigInt 是一种内置对象，用来创建比 2^53 - 1（Number 可创建的最大数字） 更大的整数。可以用来表示任意大的<strong>整数</strong></p>
<p><strong>如何定义一个 BigInt：</strong></p>
<ul>
<li>在一个整数字面量后面加 n，例如 <code>10n</code></li>
<li>调用函数 <code>BigInt()</code> 并传递一个整数值或字符串值，例如 <code>BigInt(10)</code></li>
</ul>
<p><strong>BigInt 的特点：</strong></p>
<ul>
<li>
<p>BigInt 不能用于 Math 对象中的方法；</p>
</li>
<li>
<p>BigInt 不能与任何 Number 实例混合运算，两者必须转换成同一种类型。但是需要注意，BigInt 在转换成 Number 时可能会丢失精度。</p>
</li>
<li>
<p>当使用 BigInt 时，带小数的运算会被向下取整</p>
</li>
<li>
<p>BigInt 和 Number 不是严格相等，但是宽松相等</p>
<pre><code class="language-js">0n === 0; // false
0n == 0; // true
</code></pre>
</li>
<li>
<p>BigInt 和 Number 可以比较</p>
<pre><code class="language-js">2n &gt; 2; // false
2n &gt; 1; // true
</code></pre>
</li>
<li>
<p>BigInt 和 Number 可以混在一个数组中排序</p>
<pre><code class="language-js">const mixed = [4n, 6, -12n, 10, 4, 0, 0n];
mixed.sort(); // [-12n, 0, 0n, 10, 4n, 4, 6]
</code></pre>
</li>
<li>
<p>被 Object 包装的 BigInt 使用 object 的比较规则进行比较，只用同一个对象比较时才相等</p>
<pre><code class="language-js">0n === Object(0n); // false
Object(0n) === Object(0n); // false
const o = Object(0n);
o === o; // true
</code></pre>
</li>
</ul>
<p><strong>BigInt 的方法：</strong></p>
<ul>
<li><code>BigInt.asIntN()</code><br>
将 BigInt 值转换为一个 -2^(width-1) 与 2^(width-1) - 1 之间的有符号整数。</li>
<li><code>BigInt.asUintN()</code><br>
将一个 BigInt 值转换为 0 与 2^(width) - 1 之间的无符号整数。</li>
<li><code>BigInt.prototype.toLocaleString()</code><br>
返回此数字的 language-sensitive 形式的字符串。覆盖 <code>Object.prototype.toLocaleString()</code> 方法。</li>
<li>BigInt.prototype.toString()<br>
返回以指定基数 (base) 表示指定数字的字符串。覆盖 <code>Object.prototype.toString()</code> 方法。</li>
<li>BigInt.prototype.valueOf()<br>
返回指定对象的基元值。覆盖 <code>Object.prototype.valueOf()</code> 方法。</li>
</ul>
<p><strong>为什么会有 Bigint 的提案？</strong><br>
JavaScript 中 <code>Number.MAX_SAFE_INTEGER</code>表示最大安全数字，计算结果是 9007199254740991，即在这个数字范围内不会出现精度丢失（小数除外）。但是一旦超过这个范围，js 就会出现计算不准确的情况，这在大数计算的时候就不得不依靠一些第三方库进行解决，因此官方提出了 BigInt 来解决此问题。</p>
<h2>5. <code>String.prototype.matchAll()</code></h2>
<p>返回一个包含所有匹配正则表达式的结果及分组捕获组的迭代器。</p>
<pre><code class="language-js">const regexp = /t(e)(st(\d?))/g;
const str = &quot;test1test2&quot;;
const array = [...str.matchAll(regexp)];
console.log(array[0]); // [&quot;test1&quot;, &quot;e&quot;, &quot;st1&quot;, &quot;1&quot;]
console.log(array[1]); // [&quot;test2&quot;, &quot;e&quot;, &quot;st2&quot;, &quot;2&quot;]
</code></pre>
<h2>6. <code>Promise.allSettled()</code></h2>
<p>类方法，返回一个在所有给定的 promise 都已经 fulfilled 或 rejected 后的 promise，并带有一个对象数组，每个对象表示对应的 promise 结果。</p>
<pre><code class="language-js">Promise.allSettled([
  Promise.resolve(33),
  new Promise((resolve) =&gt; setTimeout(() =&gt; resolve(66), 0)),
  99,
  Promise.reject(new Error(&quot;an error&quot;)),
]).then((values) =&gt; console.log(values));
// [
//   { status: 'fulfilled', value: 33 },
//   { status: 'fulfilled', value: 66 },
//   { status: 'fulfilled', value: 99 },
//   { status: 'rejected', reason: Error: an error }
// ]
</code></pre>
<h2>7. Dynamic import（按需 import）</h2>
<p><code>import</code> 可以在需要的时候，再加载某个模块。</p>
<pre><code class="language-js">button.addEventListener(&quot;click&quot;, (event) =&gt; {
  import(&quot;./dialogBox.js&quot;)
    .then((dialogBox) =&gt; {
      dialogBox.open();
    })
    .catch((error) =&gt; {
      /* Error handling */
    });
});
</code></pre>
<h1>ES12</h1>
<p>ES 2021（ES12）新增了如下新特性 👇：</p>
<ul>
<li>逻辑运算符和赋值表达式（&amp;&amp;=，||=，??=）</li>
<li><code>String.prototype.replaceAll()</code></li>
<li>数字分隔符</li>
<li><code>Promise.any</code></li>
</ul>
<h2>1. 逻辑运算符和赋值表达式（&amp;&amp;=，||=，??=）</h2>
<h3>&amp;&amp;=</h3>
<p>逻辑与赋值运算符 <code>x &amp;&amp;= y</code> 等价于 <code>x &amp;&amp; (x=y)</code>：意思是当 x 为真时，x = y。</p>
<pre><code class="language-js">let a = 1;
let b = 0;
a &amp;&amp;= 2;
console.log(a); // 2
b &amp;&amp;= 2;
console.log(b); // 0
</code></pre>
<h3>||=</h3>
<p>逻辑或赋值运算符 <code>x ||= y</code> 等价于 <code>x || (x = y)</code>：意思是仅在 x 为 false 的时候，x = y。</p>
<pre><code class="language-js">const a = { duration: 50, title: &quot;&quot; };
a.duration ||= 10;
console.log(a.duration); // 50
a.title ||= &quot;title is empty.&quot;;
console.log(a.title); // &quot;title is empty&quot;
</code></pre>
<h3>??=</h3>
<p>逻辑空赋值运算符 <code>x ??= y</code> 等价于 <code>x ?? (x = y)</code>：意思是仅在 x 为 null 或 undefined 的时候，x = y。</p>
<pre><code class="language-js">const a = { duration: 50 };
a.duration ??= 10;
console.log(a.duration); // 50
a.speed ??= 25;
console.log(a.speed); // 25
</code></pre>
<h2>2. <code>String.prototype.replaceAll()</code></h2>
<p>返回一个新字符串，字符串中所有满足 pattern 的部分都会被 replacement 替换掉。原字符串保持不变。</p>
<ul>
<li>pattern 可以是一个字符串或 RegExp；</li>
<li>replacement 可以是一个字符串或一个在每次被匹配被调用的函数。</li>
</ul>
<pre><code class="language-js">&quot;aabbcc&quot;.replaceAll(&quot;b&quot;, &quot;.&quot;); // 'aa..cc'
</code></pre>
<p>使用正则表达式搜索值时，必须是全局的：</p>
<pre><code class="language-js">&quot;aabbcc&quot;.replaceAll(/b/, &quot;.&quot;); // TypeError: replaceAll must be called with a global RegExp
&quot;aabbcc&quot;.replaceAll(/b/g, &quot;.&quot;); // &quot;aa..cc&quot;
</code></pre>
<h2>3. 数字分隔符</h2>
<p>ES12 允许 JavaScript 的数值使用下划线（_）作为分隔符，但是没有规定间隔的位数：</p>
<pre><code class="language-js">123_00;
</code></pre>
<p>小数和科学记数法也可以使用分隔符：</p>
<pre><code class="language-js">0.1_23;
1e10_00;
</code></pre>
<p>⚠️ 注意：</p>
<ul>
<li>不能放在数值的最前面和最后面；</li>
<li>不能将两个及两个以上的分隔符连在一起；</li>
<li>小数点的前后不能有分隔符；</li>
<li>科学记数法里，e 或 E 前后不能有分隔符。</li>
</ul>
<h2>4. <code>Promise.any</code></h2>
<p>方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。</p>
<p>只要参数实例有一个变成 fulfilled 状态，包装实例就会变成 fulfilled 状态；如果所有参数实例都变成 rejected 状态，包装实例就会变成 rejected 状态。</p>
<pre><code class="language-js">const promise1 = () =&gt; {
  return new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
      resolve(&quot;promise1&quot;);
      //  reject(&quot;error promise1 &quot;);
    }, 3000);
  });
};
const promise2 = () =&gt; {
  return new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
      resolve(&quot;promise2&quot;);
      // reject(&quot;error promise2 &quot;);
    }, 1000);
  });
};
const promise3 = () =&gt; {
  return new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
      resolve(&quot;promise3&quot;);
      // reject(&quot;error promise3 &quot;);
    }, 2000);
  });
};
Promise.any([promise1(), promise2(), promise3()])
  .then((first) =&gt; {
    // 只要有一个请求成功 就会返回第一个请求成功的
    console.log(first); // 会返回promise2
  })
  .catch((error) =&gt; {
    // 所有三个全部请求失败 才会来到这里
    console.log(&quot;error&quot;, error);
  });
</code></pre>
<pre><code class="language-js">Promise.any([promise1(), promise2(), promise3()])
  .then((first) =&gt; {
    // 只要有一个请求成功 就会返回第一个请求成功的
    console.log(first); // 会返回promise2
  })
  .catch((error) =&gt; {
    // 所有三个全部请求失败 才会来到这里
    console.log(&quot;error&quot;, error);
  });
</code></pre>
 
    </div>
  </div>
  <div class="article__wrapper_footer">
    <a class="article__wrapper_footer-left " href="/articles/167.html"><svg t="1713708729970" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="8437" width="48" height="48"><path d="M409.272947 512.57741l403.237243 403.237243a63.349415 63.349415 0 1 1-89.622481 89.622482L274.839224 557.324726a63.349415 63.349415 0 0 1 0-89.494632L722.951633 19.717685a63.349415 63.349415 0 1 1 89.494633 89.622482L409.336872 512.57741z" p-id="8438" fill="currentColor"></path></svg></a>
    <a class="article__wrapper_footer-right " href="/articles/169.html"><svg t="1713708697355" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="8093" width="48" height="48"><path d="M855.123 517.004c0 8.245-3.167 15.51-9.503 21.823L402.999 981.47c-6.336 6.336-13.625 9.477-21.869 9.477s-15.51-3.142-21.845-9.477L311.8 933.96c-6.336-6.336-9.502-13.6-9.502-21.845 0-8.222 3.167-15.51 9.502-21.845l373.29-373.29-373.293-373.267c-6.336-6.336-9.502-13.6-9.502-21.845s3.167-15.533 9.503-21.869l47.484-47.484c6.336-6.336 13.6-9.502 21.845-9.502s15.533 3.167 21.869 9.503l442.621 442.622c6.334 6.334 9.503 13.625 9.503 21.869z" fill="currentColor" p-id="8094"></path></svg></a>
  </div>
  <a class="article__wrapper_index" href="/articles/"><svg t="1713708857338" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="9656" width="48" height="48"><path d="M549.61981 133.022476l319.683047 203.605334A70.851048 70.851048 0 0 1 902.095238 396.361143v434.883047A70.89981 70.89981 0 0 1 831.146667 902.095238h-282.819048l0.024381-218.112h-71.826286v218.087619L192.853333 902.095238A70.89981 70.89981 0 0 1 121.904762 831.24419V390.241524c0-24.527238 12.678095-47.299048 33.54819-60.220953l318.659048-197.485714a70.972952 70.972952 0 0 1 75.50781 0.487619zM828.952381 828.952381V397.214476L511.488 195.047619 195.047619 391.119238V828.952381h211.309714v-216.551619h212.187429v216.527238L828.952381 828.952381z" p-id="9657" fill="#707070"></path></svg></div>
  <script src="../assets/js/prism.min.js"></script>
  <script src="../assets/js/prism-javascript.min.js"></script>
  <script src="../assets/js/articles-detail.js"></script>
</body>
</html>
    